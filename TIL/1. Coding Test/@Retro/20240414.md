- 알고리즘 문제를 한 달이 넘게 브론즈부터 차근차근 유형별로 풀어오고 있다.
- 보통 순열이나 조합, 팩토리얼 등 기본 알고리즘, 로직들을 직접 구현해서 푸는 편이다.
- 그런데, 이렇게 풀면 시간이 너무 오래걸린다.
- 이를 구현하는 시간 뿐만 아니라, 실행 시간도 오래 걸린다.

### 간단한 예시
#### 1. sum 직접 for문을 돌리며 계산
```python
A = [1, 2, 3, 4, 5]
Sum = 0

for n in A:
	Sum += n

print(Sum)
```

#### 2. 내장함수 sum 활용
```python
A = [1, 2, 3, 4, 5]
Sum = sum(A)

print(Sum)
```

- 위 2개의 예시 중, 어떤 계산이 속도가 빠를까?
- 2번과 같이 내장함수를 활용하는 것이 훨씬 빠르다.

### 내가 깨달음을 얻은 예시
#### 1. 누적 합
```python
A = [1, 2, 3, 4, 5]
Sums = [0]

for n in A:
	Sums.append(Sums[-1] + n)

print(Sums)
```

#### 2. 표준 라이브러리 itertools - accumulate 활용
```python
import itertools
A = [1, 2, 3, 4, 5]

Sums = list(itertools.accumulate(A, initial=0))
print(Sums)
```

### 결론
- 문제를 풀 때 표준 라이브러리를 활용하는 게 맞는 것 같다.
- 문제 자체도 그렇게 설계가 되어 있는 것 같다.
- 난이도가 쉬운 문제야 어떻게 풀어도 풀린다.
- 하지만, 어려워질수록 이미 누군가 잘 최적화하여 설계한 표준 라이브러리를 활용하는 게 당연한 듯 하다.