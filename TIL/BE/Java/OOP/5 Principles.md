### 1. SRP : 단일 책임의 원칙 (Single Responsibility Principle)
클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중해야 한다.
- 항상 객체들의 책임을 최상의 상태로 분배한다.
- 클래스는 자신의 이름이 나타내는 일을 해야 한다.
- 올바른 클래스의 이름은 해당 클래스의 책임을 나타내는 가장 좋은 방법이다.
- 한 클래스는 하나의 개념을 나타내고, 하나의 책임을 가진다.
- **But!** '하나의 책임'이라는 게 모호하다. 큰 책임일 수도 작은 책임일 수도 있다.
- 중요한 기준은 **변경**이다. **변경이 있을 때 파급 효과가 적으면 SRP를 잘 따른 것이다.**

### 2. OCP : 개방 폐쇄의 원칙 (Open Close Principle)
**가장 중요한 원칙이다.**
- SW 요소는 **확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.**
- 다형성을 활용한다.
- 인터페이스와 구현체를 분리한다. (역할과 구현의 분리)
	- 역할은 변경되지 않고 그대로 유지되지만, 구현은 무한히 확장 가능해야 한다.
	- 역할이 변경되지 않았기 때문에 Client는 변경될 게 없지만, 구현에 따라 그 속성이 달라진다.
	- **Example 1!** 운전자는 자동차 I/F가 바뀌지 않았기 때문에 멈출 때는 브레이크, 나아갈 때는 엑셀을 밟는다. 이는 K3, 아반떼, 그렌저, 테슬라, 벤츠 어떤 자동차를 타더라도 동일하다.
	- **Example 2!** 로미오 역할의 배우는 줄리엣 역할과 합을 맞추는 것이지, 줄리엣 역할을 하는 배우에 상관 없이 로미오 역할이 동일하다. 달라지면 안된다.


### 3. LSP : 리스코브 치환의 원칙 (The Liskov Substitution Principle)
인터페이스의 구현체는 인터페이스 규약을 모두 지켜야 한다. 인터페이스를 구현한 구현체를 믿고 사용하기 위해, 이 원칙이 필요하다.
- **Example!** 자동차 인터페이스를 따르는 K3, 아반떼가 있다면 엑셀은 무조건 앞으로 속도가 빨라진다. 브레이크는 멈춰야 한다. 엑셀을 밟는데 속도가 느려지거나 뒤로 간다면 LSP 위반이다.

### 4. ISP : 인터페이스 분리의 원칙 (Interface Segregation Principle)
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. **인터페이스의 역할이 명확해지고,** 대체 가능성이 높아진다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리를 할 경우, 정비 인터페이스가 바뀌어도 운전자 클라이언트에 영향이 없다.

### 5. DIP : 의존성 역전의 원칙 (Depenedency Inversion Principle)
**개발자는 추상화에 의존해야 하고, 구체화에 의존하면 안된다.** 의존성 주입 (DI)은 이 원칙을 따르는 방법이다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.
- 클라이언트가 구현 클래스를 의존하면 안된다. 역할에만 의존해야 한다.

```java
// carService를 HongCarService -> SeulCarService로 변경을 하는 경우
// private CarService carService = new HongCarService;
private CarService carService = new SeulCarService;
```
- 객체 지향의 핵심은 **다형성**. 
- **But!** 위 코드는 다형성은 지켰지만, OCP, DIP를 위반한다. 다형성만으로는 OCP, DIP를 지킬 수 없다.
- 뭔가 더 필요하다.