### 1. 빌더 패턴
> 아래와 같은 생성자를 통한 객체 생성 패턴의 단점을 극복한다.

- 기본적으로 객체를 생성할 때, 생성자를 통해 객체를 생성한다.
- 다만, 객체의 필드 수가 적을 때는 한 눈에 봐도 1번째 값, 2번째 값이 어떤 것인 지 알겠지만, 필드 수가 많아질 경우 8번째 값이 어떤 값인지 모르게 된다.
- 실수로 입력하는 필드의 순서가 바뀔 경우, 두 필드가 서로 다른 타입이면 에러가 발생하니까 단번에 알 수 있지만... 혹시라도 동일한 타입일 경우 에러가 잡히지 않으니까 대형 사고로 이어질 수 있다.
- 또한, 2개의 매개변수만 세팅하고 싶은데, 다른 필드의 값까지 채워줘야 하는 단점이 있다.

참고 : [빌더패턴의 역사](https://squirmm.tistory.com/entry/SpringJava-Builder)
참고 : [Builder() 심화 속성](https://adjh54.tistory.com/96)
참고 : [빌더 디폴트값](https://bbeomgeun.tistory.com/174)

### 2. 싱글톤 패턴
- 싱글톤 패턴을 적용하면, 고객의 요청이 들어올 때마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.
- 싱글톤 패턴을 구현하는 방법은 여러가지가 있다.
- 하지만, 싱글톤 패턴은 다음과 같은 수 많은 문제점들을 갖고 있다.

#### 2-1. 싱글톤 패턴의 문제점
- 이를 구현하는 코드가 자체적으로 많이 필요하다.
- 의존관계상 클라이언트가 구현체를 의존하기 때문에 DIP를 위반한다. **(DIP : [[5 Principles#5. DIP 의존성 역전의 원칙 (Depenedency Inversion Principle)]])**
- 구현체를 의존하기 때문에 OCP 원칙을 위반할 가능성이 높다. **(OCP : [[5 Principles#2. OCP 개방 폐쇄의 원칙 (Open Close Principle)]])**
- 구현체를 의존해야하는 getInstance를 미리 생성해둬야 하고, 생성하고 끝이기 때문에 유연성이 떨어진다.
- 유연성이 떨어져서 내부 속성을 변경하거나 초기화하면서 테스트 하기 어렵다.
- private 생성자를 쓰기 때문에 자식 클래스를 만들기 어렵다.
- 안티패턴으로 불리기도 한다.