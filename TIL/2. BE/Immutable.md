> 백엔드를 개발할 때, 왜 불변을 강조하는 것일까?

참고 : [불변 객체에 대해 알아야할 5가지](https://buttercms.com/blog/5-things-you-should-know-about-immutable-objects/)
참고 : [6가지 베네핏](https://www.linkedin.com/pulse/20140528113353-16837833-6-benefits-of-programming-with-immutable-objects-in-java)
참고 : [장점과 단점](https://en.proft.me/2013/11/24/advantages-and-disadvantages-immutable-objects-jav/)

```java
class Time(t: Double) {
  private var time = t // Danger: mutable field
  def getTime = time
  def setTime(t: Double): Unit = time = t
}

val startAt = new Time(5.0)
val someOtherTime = startAt
someOtherTime.setTime(10.0)

// What does startAt.getTime return?
```

`someOtherTime.setTime(10.0)`이 간단한 예에서 반환 후에 가 대신 `startAt.getTime`값을 갖게 된다는 사실에 놀랄 수도 있고 그렇지 않을 수도 있습니다 . 특히 그것이 이라는 점을 감안할 때 그것을 예상했습니까 ?`10.0` `5.0` `startAt` `val`

코드를 본 적이 있다면 아마도 예상한 대로일 것입니다. 하지만, 내부를 보지 않고 그냥 사용했다면 `Time`, 그 동작에 매우 놀랐을 것이라고 생각합니다. 변경 가능한 개체의 상태는 변경 사항을 인식하지 못한 채 변경될 수 있습니다. 특히 액세스가 `Time.time`동기화되어야 하는 다중 스레드 환경에서는 더욱 그렇습니다. 그러나 단일 스레드의 경우에도 예상치 못한 복잡성이 발생할 수 있습니다.

객체를 불변으로 유지하면 추론하기가 쉬워집니다. 해당 객체가 _값 유형을_ 나타내는 경우 불변성은 실제로 필수적입니다. (변경 불가능하지 않은 주요 프로그래밍 언어 또는 라이브러리의 단일 값 유형을 지정하십시오.)

단일 스레드 코딩과 다중 스레드 코딩에 대한 추가 사항: 단일 스레드 애플리케이션을 작성하는 경우 스레드 안전을 문제로 완전히 무시하고 싶은 유혹을 받을 수 있습니다. 그러나 일반적인 경우에는 조금 근시안적이라고 생각합니다. 모든 새로운 프로세서에는 다중 코어가 있으며, 앞으로 몇 년 동안 프로세서가 점점 더 많은 코어를 갖게 될 것으로 보입니다. 반응성이 뛰어난 고성능 코드를 작성하려면 스레드로부터 안전한 라이브러리를 사용하여 다중 스레드 애플리케이션을 작성해야 합니다.

_스레드로부터 안전하지 않은 코드를 작성하고 공유 변경 가능 상태를_ 나타내는 변경 가능한 개체가 많이 포함되어 있는 경우 멀티 스레드에서 사용하기에 적합하도록 엄청난 양의 리팩토링을 수행해야 합니다. 응용 프로그램. 반면에 객체가 변경 불가능하고 공유된 변경 가능 상태가 없다면 해당 작업은 훨씬 더 쉬워질 것입니다.

덧붙여서, 변경 가능한 상태가 공유되지 않는 경우(예: 외부에서 볼 수 있는 경우) 함수, 클래스 등에서 변경 가능한 상태를 사용하는 것이 완벽하게 가능합니다. 이렇게 하면 단점 없이 변경 가능한 상태 성능의 이점을 누릴 수 있습니다.

### 다중 스레드에서만 불변이 중요할까? 그렇다면 공유된 불변 객체는 어떻게 유용합니까?

내 질문의 첫 번째 부분에 대한 대답은 "예"라고 생각합니다. 단일 스레드 응용 프로그램에서 객체를 불변으로 만드는 데 아무런 의미가 없습니다(또는 다중 스레드 응용 프로그램에서 해당 특정 객체가 스레드 간에 공유되지 않는지 추측합니다). ). 제가 틀렸다면 단일 스레드 앱에서 불변 객체가 유용한 이유를 설명해 주세요.

두 번째 부분은 불변 객체를 공유하는 경우 변경할 수 없다면 어떤 용도로 유용할까요? 공유되는 이유는 무엇인가요? 객체의 새 버전과 변경된 버전이 생성되도록 "변경"된 경우(예: 공유 카운터), 변경으로 인해 새 객체가 만들어지면 이 공유 객체는 어떻게 사용됩니까? 다른 스레드는 어떻게 새 버전에 액세스합니까? 더 광범위하게 말하면, 다중 스레드 애플리케이션에서 불변 개체는 어떻게 처리됩니까? 공유되지만 불변 카운터가 여러 스레드 간에 어떻게 증가하는지 추측합니다. 나는 광범위하게 검색했고 내가 읽은 것은 변경 가능한 객체에서도 수행될 수 있는 일종의 잠금 또는 원자 작업과 관련된 토론뿐이라고 생각합니다.

마지막으로, 불변 공유 카운터가 유용하다면 변경 가능한 공유 카운터에 대한 액세스를 잠그는 것보다 조작이 더 간단하고 디버깅이 더 간단합니까?

---
아니요, 불변 객체는 일반적으로 매우 유용합니다.

첫 번째이자 가장 기본적인 이유는 시스템의 동시성에는 다중 스레드 애플리케이션이 필요하지 않기 때문입니다. 예를 들어, 데이터베이스의 행을 변경할 수 없게 만들면 변경 내용 추적, 충돌 방지, 동기화 및 백업에 많은 이점을 제공합니다.

동시 시나리오에 비해 가치는 떨어지지만 불변 개체는 앱 수명 전반에 걸쳐 개체 상태를 _알고_ 일부 기능이 오작동하거나 개체를 변경하지 않는다는 것을 _알기_ 때문에 사용 및 디버깅이 더 쉬운 경향이 있습니다 . 또한 모든 종류의 예외 상태는 나중에 처리하는 동안 일부 변형이 발생하는 것이 아니라 객체 생성 시 즉시 표시됩니다. 이러한 현상은 식별하기가 더 쉽고 깨끗하게 복구하거나 중단하기가 더 쉬운 곳에서 발생합니다.

> 두 번째 부분은 불변 객체를 공유하는 경우 변경할 수 없다면 어떤 용도로 유용할까요? 공유되는 이유는 무엇인가요?

가장 확실한 예는 구성입니다. 런타임 시 변경하고 싶지 않지만 코드의 다른 부분에서 필요한 경우가 많습니다. 현재 사용자와 같은 것입니다. 이를 변경하고 싶지 않지만 다른 모듈과 공유하고 싶을 것입니다.

> 객체의 새 버전과 변경된 버전이 생성되도록 "변경"된 경우(예: 공유 카운터), 변경으로 인해 새 객체가 만들어지면 이 공유 객체는 어떻게 사용됩니까? 다른 스레드는 어떻게 새 버전에 액세스합니까?

_따라서 (대부분의 언어에서) 불변 객체의 가장 큰 점은 객체_ 쓰기가 원자적이라는 것입니다. 중단할 수 없습니다.

변경 가능한 객체의 몇 가지 필드를 변경하고 싶다고 가정해 보겠습니다. 스레드는 하나, 다른 것, 또 다른 것을 변경합니다. 다른 스레드는 각 단계 사이에서 개체를 읽을 수 있습니다. 절반만 변경된 개체가 표시됩니다.

그러나 불변 객체의 몇 가지 필드를 변경하려는 경우에는 다릅니다. 스레드는 변경하려는 세 필드를 변경하여 새 개체를 만듭니다. 그런 다음 중단할 수 없는 한 단계로 공유 참조를 덮어씁니다. 다른 스레드는 개체에 대한 참조를 가져와 변경되지 않음을 알 수 있습니다. 다른 스레드가 쓰기를 수행하기 전에 참조를 가져오면 _이전_ 개체를 얻을 수 있지만 절반이 변경된 개체는 얻을 수 없습니다.

카운터의 경우 그다지 중요하지 않습니다. int를 증가시키는 것은 새로운 int에 대한 참조를 할당하는 것과 마찬가지로 중단할 수 없습니다(단, 언어, 컴파일러, 대상 CPU 등에 따라 int보다 큰 카운터가 필요한 경우 적용되지 않을 수도 있음). 그러나 잠금은 대부분의 언어/플랫폼에서 매우 비용이 많이 들기 때문에 프로그래머는 안전할 때 이를 피할 것입니다.

---
불변 객체는 **멀티스레딩과 별개로 유용합니다** .

- **참조 유형 (예: Java 및 C#의 클래스)이** **[값 의미론](https://en.m.wikipedia.org/wiki/Value_semantics)** 구현에 사용될 때 매우 불쾌한 버그를 방지합니다 . 이 상황은 참조 유형에 내재된 잠재적인 [객체 공유를](https://www.techiedelight.com/copy-objects-in-java/) 잊게 만드는 정신적 함정을 만듭니다. , 예상하지 못한 부작용이 발생할 수 있습니다. 그러면 불변성은 객체의 값을 변경하려면 새 객체가 필요하다는 가치 의미론적 원칙을 시행하는 데 도움이 됩니다.
- 불변성은 또한 우발적인 변경의 위험을 줄여 코드의 버그를 방지하는 데 도움이 될 수 있습니다(특히 조건식에서 할당 연산자를 허용하는 언어의 경우).

**[멀티스레딩에 사용하면 경쟁 조건](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html)** **이 없다는[](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html)** 이점을 얻을 수 있습니다 . 따라서 중요한 섹션 내에 액세스를 묶을 필요 없이 이를 사용할 수 있습니다.
